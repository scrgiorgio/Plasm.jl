julia> using Plasm, LinearAlgebra

import Base.+  
+(f::Function, g::Function) = (x...) -> f(x...) + g(x...)  

import Base.*
*(p::Hpc, q::Hpc) == Plasm.Power(p, q)

export IsPolytope, IsSimplex, simplex, simplexfacets, CHULL, CUBOIDGRID, GRID1

# //////////////////////////////////////////////////////////////////////////////

IsPolytope = AND ∘ CONS([  # pure FL style
   ISPOL, 
   EQ ∘ CONS([LEN ∘ S2 ∘ UKPOL, K(1)])
])

# //////////////////////////////////////////////////////////////////////////////

IsSimplex = AND ∘ CONS([  # pure FL style
   IsPolytope, 
   EQ ∘ CONS([LEN ∘ S1 ∘ UKPOL, RN + K(1)]) 
])

# //////////////////////////////////////////////////////////////////////////////



julia> SIMPLEX(1)
Hpc(MatrixNd(2), Geometry[Geometry([[0.0], [1.0]], hulls=[[1, 2]])])

julia> SIMPLEX(2)
Hpc(MatrixNd(3), Geometry[Geometry([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]], hulls=[[1, 2, 3]])])

julia> SIMPLEX(3)
Hpc(MatrixNd(4), Geometry[Geometry([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]], hulls=[[1, 2, 3, 4]])])

julia> SIMPLEX(4)
Hpc(MatrixNd(5), Geometry[Geometry([[0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]], hulls=[[1, 2, 3, 4, 5]])])

# //////////////////////////////////////////////////////////////////////////////

julia> ToLAR(SIMPLEX(1))
Hpc(MatrixNd(1), Geometry[Geometry(Vector{Float64}[])])

julia> ToLAR(SIMPLEX(2))
Hpc(MatrixNd(3), Geometry[Geometry([[1.0, 0.0], [0.0, 0.0], [0.0, 1.0]], hulls=[[1, 2, 3]], edges=[[2, 3], [1, 2], [1, 3]], facets=[[3, 2, 1]])])

julia> ToLAR(SIMPLEX(3))
Hpc(MatrixNd(4), Geometry[Geometry([[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 1.0]], hulls=[[1, 2, 3, 4]], edges=[[2, 3], [1, 3], [1, 2], [3, 4], [2, 4], [1, 4]], facets=[[2, 3, 1], [4, 3, 2], [1, 3, 4], [4, 2, 1]])])

julia> ToLAR(SIMPLEX(4))
Hpc(MatrixNd(5), Geometry[Geometry([[0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]], edges=[[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]], facets=[[1, 2, 3, 4, 5]])])


# /////////////////////////////////////////////////////////////////////////////

julia> LAR(CUBOID([1,1]))
Lar(2, 2, 4, [1.0 0.0 1.0 0.0; 0.0 0.0 1.0 1.0], Dict{Symbol, AbstractArray}(:CV => [[1, 2, 3, 4]], :FV => [[1, 2, 3, 4]], :EV => Vector{Int64}[]))

julia> LAR(CUBOID([1,1,1]))
Lar(3, 3, 8, [1.0 0.0 … 1.0 0.0; 1.0 1.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], Dict{Symbol, AbstractArray}(:CV => [[1, 2, 3, 4, 5, 6, 7, 8]], :FV => [[1, 2, 3, 4], [1, 2, 7, 8], [1, 3, 5, 7], [2, 4, 6, 8], [3, 4, 5, 6], [5, 6, 7, 8]], :EV => [[1, 2], [1, 3], [1, 7], [2, 4], [2, 8], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7], [6, 8], [7, 8]]))

julia> LAR(CUBOID([1,1,1,1]))
Lar(4, 4, 16, [0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], Dict{Symbol, AbstractArray}(:CV => Vector{Int64}[], :FV => [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]], :EV => Vector{Int64}[]))

# /////////////////////////////////////////////////////////////////////////////

julia> function simplex(d; complex=false)
   V = [zeros(d,1) I]
   CV = [collect(1:d+1)]
   C = Dict(Symbol("C$(d)V") => CV)
   if complex == false return Lar(V,C)
   else
      cells = CV
      for k=d:-1:1
      	 cells = simplexfacets(cells)
	 	 key = Symbol("C$(k-1)V")
         push!(C, (key => cells) )
      end
      return Lar(V,C)
   end
end  

julia> function simplexfacets(simplices)
   @assert hcat(simplices...) isa Matrix
   out = Array{Int64,1}[]
	for simplex in simplices
		for v in simplex
			facet = setdiff(simplex,v)
			push!(out, facet)
		end
	end
	# remove duplicate facets
	return sort(collect(Set(out)))
end

# //////////////////////////////////////////////////////////////////////////////
julia> simplex6 = simplex(6,complex=true);

julia> simplex6.V
6×7 Matrix{Float64}:
 0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0

julia> simplex6.C
Dict{Symbol, AbstractArray} with 7 entries:
  :C6V => [[1, 2, 3, 4, 5, 6, 7]]
  :C5V => [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 7], [1, 2, 3, 4, 6, 7], [1, 2, 3…
  :C4V => [[1, 2, 3, 4, 5], [1, 2, 3, 4, 6], [1, 2, 3, 4, 7], [1, 2, 3, 5, 6], …
  :C3V => [[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 3, 6], [1, 2, 3, 7], [1, 2, 4, 5]…
  :C0V => [[1], [2], [3], [4], [5], [6], [7]]
  :C2V => [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 2, 6], [1, 2, 7], [1, 3, 4], [1…
  :C1V => [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [2, 3], [2, 4], [2, …

julia> Hpc(simplex6.V, simplex6.C[:C5V]); # OK

julia> Simplex6 = Lar(Hpc(simplex6.V, simplex6.C[:C5V]))
Lar(6, 6, 7, [1.0 0.0 … 0.0 0.0; 0.0 1.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 1.0 0.0], Dict{Symbol, AbstractArray}(:FV => [[5, 4, 6, 2, 3, 1], [5, 4, 6, 7, 2, 3], [5, 4, 6, 7, 3, 1], [5, 4, 6, 7, 2, 1], [5, 6, 7, 2, 3, 1], [4, 6, 7, 2, 3, 1], [5, 4, 7, 2, 3, 1]], :EV => Vector{Int64}[]))

# //////////////////////////////////////////////////////////////////////////////

julia> CUBOID([1])
Hpc(MatrixNd(2), Hpc[Hpc(MatrixNd(2), Geometry[Geometry([[0.0], [1.0]], hulls=[[1, 2]])])])


julia> CUBOID([1,1])
Hpc(MatrixNd(3), Hpc[Hpc(MatrixNd(3), Geometry[Geometry([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]], hulls=[[1, 2, 3, 4]])])])

julia> CUBOID([1,1,1])
Hpc(MatrixNd(4), Hpc[Hpc(MatrixNd(4), Geometry[Geometry([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [1.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0]], hulls=[[1, 2, 3, 4, 5, 6, 7, 8]])])])

julia> CUBOID([1,1,1,1])
Hpc(MatrixNd(5), Hpc[Hpc(MatrixNd(5), Geometry[Geometry([[0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [1.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [1.0, 0.0, 1.0, 0.0], [0.0, 1.0, 1.0, 0.0], [1.0, 1.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0], [1.0, 0.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0], [0.0, 0.0, 1.0, 1.0], [1.0, 0.0, 1.0, 1.0], [0.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0]], hulls=[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]])])])

# //////////////////////////////////////////////////////////////////////////////

# julia> Lar(CUBOID([1]))
# ERROR: MethodError: no method matching Lar(::Vector{Any}, ::Dict{Symbol, Vector{Vector{Int64}}})

julia> Lar(CUBOID([1,1]))
Lar(2, 2, 4, [1.0 0.0 0.0 1.0; 1.0 1.0 0.0 0.0], Dict{Symbol, AbstractArray}(:FV => [[4, 2, 3, 1]], :EV => Vector{Int64}[]))  # EV empty

julia> obj2 = Hpc(Lar(CUBOID([1,1])))
Hpc(MatrixNd(3), Hpc[Hpc(MatrixNd(3), Geometry[Geometry([[0.0, 1.0], [0.0, 0.0], [1.0, 0.0], [1.0, 1.0]], hulls=[[1, 2, 3, 4]])])])

julia> VIEW(Hpc(Lar(obj2).V, Lar(obj2).C[:FV])) # OK

# julia> VIEW(Hpc(Lar(obj2).V, Lar(obj2).C[:EV])) # KO

# //////////////////////////////////////////////////////////////////////////////

julia> Lar(CUBOID([1,1,1]))
Lar(3, 3, 8, [1.0 0.0 … 1.0 0.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], Dict{Symbol, AbstractArray}(:FV => [[4, 2, 3, 1], [5, 6, 2, 1], [5, 4, 7, 1], [6, 2, 8, 3], [4, 7, 8, 3], [5, 6, 7, 8]], :EV => [[2, 1], [2, 3], [4, 1], [4, 3], [4, 7], [5, 1], [5, 6], [5, 7], [6, 2], [6, 8], [7, 8], [8, 3]]))

julia> obj3 = Hpc(Lar(CUBOID([1,1,1]))); # OK

julia> Lar(obj)
Lar(3, 3, 8, [1.0 0.0 … 0.0 1.0; 0.0 0.0 … 0.0 0.0; 1.0 1.0 … 0.0 0.0], Dict{Symbol, AbstractArray}(:FV => [[4, 2, 3, 1], [5, 4, 6, 3], [4, 6, 7, 2], [5, 8, 3, 1], [7, 2, 8, 1], [5, 6, 7, 8]], :EV => [[2, 1], [3, 1], [4, 2], [4, 3], [4, 6], [5, 3], [5, 6], [5, 8], [6, 7], [7, 2], [7, 8], [8, 1]]))  # OK

julia> VIEW(Hpc(Lar(obj3).V, Lar(obj3).C[:EV])) # OK

julia> VIEW(Hpc(Lar(obj3).V, Lar(obj3).C[:FV])) # OK

# //////////////////////////////////////////////////////////////////////////////

using QHull # REMARK

function CHULL(points::Matrix)
   convexhull = QHull.chull(points)
   FV = convexhull.simplices
   pairs = [map(sort,[[i,j],[i,k],[j,k]]) for (i,j,k) in FV]
   EV = sort!(union(vcat(pairs...)))
   ret = Lar(2, Matrix(p'), Dict(:EV => EV, :FV => FV))
end

# //////// STRUCT //////////////////////////////////////////////////////////////

julia> test2cubes = LAR(STRUCT(SQUARE(1), T(1,2)(0.5,0.25), SQUARE(1))) # 2D
Lar(2, 2, 8, [1.5 0.5 … 1.0 0.0; 0.25 0.25 … 1.0 1.0], Dict{Symbol, AbstractArray}(:CV => [[1, 2, 3, 4], [5, 6, 7, 8]], :FV => [[1, 2, 3, 4], [5, 6, 7, 8]], :EV => Vector{Int64}[])) # KO:  FV deve essere d-1, mentre EV = [] 

julia> test2cubes = LAR(STRUCT(CUBE(1), T(1,2)(0.5,0.25), CUBE(1))) # 3D |V|=16,|FV|=12,|EV|=24 ... OK!
Lar(3, 3, 16, [1.5 0.5 … 1.0 0.0; 1.25 1.25 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], Dict{Symbol, AbstractArray}(:CV => [[1, 2, 3, 4, 5, 6, 7, 8], [9, 10, 11, 12, 13, 14, 15, 16]], :FV => [[1, 2, 3, 4], [1, 2, 7, 8], [1, 3, 5, 7], [2, 4, 6, 8], [3, 4, 5, 6], [5, 6, 7, 8], [9, 10, 11, 12], [9, 10, 15, 16], [9, 11, 13, 15], [10, 12, 14, 16], [11, 12, 13, 14], [13, 14, 15, 16]], :EV => [[1, 2], [1, 3], [1, 7], [2, 4], [2, 8], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7]  …  [9, 15], [10, 12], [10, 16], [11, 12], [11, 13], [12, 14], [13, 14], [13, 15], [14, 16], [15, 16]]))

julia> test2cubes = LAR(STRUCT(CUBE(1), T(1)(1), CUBE(1))) # |V|=12,|FV|=11,|EV|=20 ... OK!  correct by using LAR ... uncorrect using Lar !!!
Lar(3, 3, 12, [2.0 1.0 … 0.0 0.0; 1.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0], Dict{Symbol, AbstractArray}(:CV => [[1, 2, 3, 4, 5, 6, 7, 8], [2, 9, 4, 10, 6, 11, 8, 12]], :FV => [[1, 2, 3, 4], [1, 2, 7, 8], [1, 3, 5, 7], [2, 4, 6, 8], [2, 4, 9, 10], [2, 8, 9, 12], [3, 4, 5, 6], [4, 6, 10, 11], [5, 6, 7, 8], [6, 8, 11, 12], [9, 10, 11, 12]], :EV => [[1, 2], [1, 3], [1, 7], [2, 4], [2, 8], [2, 9], [3, 4], [3, 5], [4, 6], [4, 10], [5, 6], [5, 7], [6, 8], [6, 11], [7, 8], [8, 12], [9, 10], [9, 12], [10, 11], [11, 12]]))

julia> cube3 = (LAR∘STRUCT∘CAT∘DIESIS(3))([T(1)(1), CUBE(1)]); # NB:  LAR  !!!

julia> AA(LEN)(values(cube3.C)) # OK
3-element Vector{Int64}:
  3
 16
 28 
size(cube3.V,2)-28+16-(3+1) = 0 # topologia 3-sfera OK!  (da un 3-complex)

julia> VIEW(Hpc(cube3.V, cube3.C[:EV])) # OK

julia> VIEW(Hpc(cube3.V, cube3.C[:FV])) # OK

# /////// FL GRID1 /////////////////////////////////////////////////////////////

julia> GRID1(n) = QUOTE(DIESIS(n)(1.0))
GRID1 (generic function with 1 method)

julia> grid1D = INTERVALS(10.0)(10) # equivalent to the next
Hpc(MatrixNd(2), Geometry[Geometry([[0.0], [1.0], [2.0], [3.0], [4.0], [5.0], [6.0], [7.0], [8.0], [9.0], [10.0]], hulls=[[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11]])])

julia> grid1D = QUOTE(DIESIS(10)(1.0)) # equivalent to the former
Hpc(MatrixNd(2), Geometry[Geometry([[0.0], [1.0], [2.0], [3.0], [4.0], [5.0], [6.0], [7.0], [8.0], [9.0], [10.0]], hulls=[[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11]])])

julia> domain3D = LAR(grid1D * grid1D * grid1D)
Lar(3, 3, 1331, [1.0 0.0 … 9.0 10.0; 1.0 1.0 … 10.0 10.0; 0.0 0.0 … 10.0 10.0], Dict{Symbol, AbstractArray}(:CV => [[1, 2, 3, 4, 5, 6, 7, 8], [9, 1, 10, 3, 11, 5, 12, 7], [13, 9, 14, 10, 15, 11, 16, 12], [17, 13, 18, 14, 19, 15, 20, 16], [21, 17, 22, 18, 23, 19, 24, 20], [25, 21, 26, 22, 27, 23, 28, 24], [29, 25, 30, 26, 31, 27, 32, 28], [33, 29, 34, 30, 35, 31, 36, 32], [37, 33, 38, 34, 39, 35, 40, 36], [41, 37, 42, 38, 43, 39, 44, 40]  …  [1200, 1201, 1189, 1190, 1310, 1311, 1321, 1322], [1202, 1200, 1191, 1189, 1312, 1310, 1323, 1321], [1203, 1202, 1192, 1191, 1313, 1312, 1324, 1323], [1204, 1203, 1193, 1192, 1314, 1313, 1325, 1324], [1205, 1204, 1194, 1193, 1315, 1314, 1326, 1325], [1206, 1205, 1195, 1194, 1316, 1315, 1327, 1326], [1207, 1206, 1196, 1195, 1317, 1316, 1328, 1327], [1208, 1207, 1197, 1196, 1318, 1317, 1329, 1328], [1209, 1208, 1198, 1197, 1319, 1318, 1330, 1329], [1210, 1209, 1199, 1198, 1320, 1319, 1331, 1330]], :FV => [[1, 2, 3, 4], [1, 2, 7, 8], [1, 2, 45, 46], [1, 3, 5, 7], [1, 3, 9, 10], [1, 7, 9, 12], [1, 7, 45, 47], [1, 9, 45, 49], [2, 4, 6, 8], [2, 8, 46, 48]  …  [1310, 1311, 1321, 1322], [1310, 1312, 1321, 1323], [1312, 1313, 1323, 1324], [1313, 1314, 1324, 1325], [1314, 1315, 1325, 1326], [1315, 1316, 1326, 1327], [1316, 1317, 1327, 1328], [1317, 1318, 1328, 1329], [1318, 1319, 1329, 1330], [1319, 1320, 1330, 1331]], :EV => [[1, 2], [1, 3], [1, 7], [1, 9], [1, 45], [2, 4], [2, 8], [2, 46], [3, 4], [3, 5]  …  [1321, 1322], [1321, 1323], [1323, 1324], [1324, 1325], [1325, 1326], [1326, 1327], [1327, 1328], [1328, 1329], [1329, 1330], [1330, 1331]]))

julia> size(domain3D.V,2) - LEN(domain3D.C[:EV]) + LEN(domain3D.C[:FV]) -LEN( domain3D.C[:CV]) +1 == 2  # KO:  should give 0  


# ///////// CUBOIDGRID /////////////////////////////////////////////////////////

function CUBOIDGRID(shape::Vector{Int})
   LAR(INSL(POWER)(AA(GRID1)(shape)))
end

julia> mesh = CUBOIDGRID([5,5,5])

julia> VIEW(Hpc(mesh.V, mesh.C[:EV]))

julia> GRID1(5)
Hpc(MatrixNd(2), Geometry[Geometry([[0.0], [1.0], [2.0], [3.0], [4.0], [5.0]], hulls=[[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]])])


julia> mesh = CUBOIDGRID([10,10])
Lar(2, 2, 121, [1.0 0.0 … 9.0 10.0; 0.0 0.0 … 10.0 10.0], Dict{Symbol, AbstractArray}(:CV => [[1, 2, 3, 4], [5, 1, 4, 6], [7, 5, 6, 8], [9, 7, 8, 10], [11, 9, 10, 12], [13, 11, 12, 14], [15, 13, 14, 16], [17, 15, 16, 18], [19, 17, 18, 20], [21, 19, 20, 22]  …  [101, 100, 111, 112], [102, 101, 112, 113], [103, 102, 113, 114], [104, 103, 114, 115], [105, 104, 115, 116], [106, 105, 116, 117], [107, 106, 117, 118], [108, 107, 118, 119], [109, 108, 119, 120], [110, 109, 120, 121]], :FV => [[1, 2, 3, 4], [1, 4, 5, 6], [3, 4, 23, 24], [4, 6, 24, 25], [5, 6, 7, 8], [6, 8, 25, 26], [7, 8, 9, 10], [8, 10, 26, 27], [9, 10, 11, 12], [10, 12, 27, 28]  …  [100, 101, 111, 112], [101, 102, 112, 113], [102, 103, 113, 114], [103, 104, 114, 115], [104, 105, 115, 116], [105, 106, 116, 117], [106, 107, 117, 118], [107, 108, 118, 119], [108, 109, 119, 120], [109, 110, 120, 121]], :EV => [[1, 4], [3, 4], [4, 6], [4, 24], [5, 6], [6, 8], [6, 25], [7, 8], [8, 10], [8, 26]  …  [105, 106], [105, 116], [106, 107], [106, 117], [107, 108], [107, 118], [108, 109], [108, 119], [109, 110], [109, 120]]))

julia> AA(LEN)(values(mesh.C)) # KO on meaning of cell complexess
3-element Vector{Int64}:
 100  # <= valori errati
 100
 180 
 
julia> size(mesh.V,2), LEN(mesh.C[:EV]), LEN(mesh.C[:FV]) # CV == FV
(121, 180, 100)  # error in computing 180 as |EV| instead than 220

julia> 121 - 220 + 100+1 == 2  # (result of Euler characteristic in 2D) 


julia> VIEW(Hpc(mesh.V, mesh.C[:EV])) # problema ai bordi

julia> VIEW(Hpc(mesh.V, mesh.C[:FV])) # OK ai bordi

# //////////////////////////////////////////////////////////////////////////////

